<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <title>Viewer - WebRTC + Detection (WASM)</title>
  <style>
    body { margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: #0b0b0b; color: #f5f5f5; }
    .wrap { padding: 12px; }
    .row { display: flex; gap: 16px; flex-wrap: wrap; align-items: flex-start; }
    .card { background: #141414; padding: 12px; border-radius: 8px; }
    #qr { display: block; }
    .video-wrap { position: relative; max-width: 800px; width: 100%; }
    #remoteVideo { display: block; width: 100%; height: auto; background: #000; object-fit: cover; }
    #overlay { position: absolute; inset: 0; width: 100%; height: 100%; pointer-events: none; }
    #hud { margin-top: 8px; color: #cfcfcf; font-size: 0.95rem; }
    button { padding: 8px 12px; border: 0; border-radius: 6px; background: #00b15a; color: #fff; cursor: pointer; }
    button:disabled { opacity: 0.6; cursor: default; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace; word-break: break-all; }
  </style>
</head>
<body>
  <div class="wrap">
    <h3>Viewer - Receiver + WASM Face Detection</h3>
    <div class="row">
      <div class="card">
        <canvas id="qr" width="180" height="180"></canvas>
        <div id="joinUrl" class="mono"></div>
        <div style="margin-top:8px;">
          <button id="startMetrics">Start Metrics (30s)</button>
          <button id="saveMetrics" disabled>Save metrics.json</button>
        </div>
      </div>
      <div class="video-wrap card">
        <video id="remoteVideo" autoplay playsinline muted></video>
        <canvas id="overlay"></canvas>
        <div id="hud">Faces: 0 | FPS: 0 | Lat (p50/p95): 0/0 ms | Up/Down: 0/0 kbps</div>
      </div>
    </div>
  </div>

  <script type="module">
    import { connectSignaling, createPeerConnection, makeOffer, makeAnswer } from './webrtc.js';
    import { drawMiniQR } from './qr.js';
    import { initDetector, enqueueFrame, startProcessing, stopProcessing, CONFIG, getMetrics } from './wasm_detector.js';

    const remoteVideo = document.getElementById('remoteVideo');
    const overlay = document.getElementById('overlay');
    const ctx = overlay.getContext('2d');
    const joinUrlEl = document.getElementById('joinUrl');
    const qrCanvas = document.getElementById('qr');
    const hudEl = document.getElementById('hud');
    const startBtn = document.getElementById('startMetrics');
    const saveBtn = document.getElementById('saveMetrics');

    function resizeCanvasToVideo() {
      const w = remoteVideo.videoWidth || remoteVideo.clientWidth || 0;
      const h = remoteVideo.videoHeight || remoteVideo.clientHeight || 0;
      if (!w || !h) return;
      if (overlay.width !== w || overlay.height !== h) {
        overlay.width = w; overlay.height = h;
      }
      ctx.clearRect(0, 0, overlay.width, overlay.height);
    }

    function roomId() { return Math.random().toString(36).slice(2, 8); }

    function getLANUrl(path) {
      const { hostname } = window.location;
      // If localhost, also show current LAN hostname/IP
      const port = window.location.port ? ':' + window.location.port : '';
      return `${window.location.protocol}//${hostname}${port}${path}`;
    }

    function drawDetections(dets) {
      const w = overlay.width, h = overlay.height;
      ctx.clearRect(0, 0, w, h);
      if (!dets || dets.length === 0) return;
      ctx.save(); ctx.strokeStyle = '#00FF00'; ctx.lineWidth = 2;
      for (const d of dets) {
        const bb = d.boundingBox; if (!bb) continue;
        const x = Math.floor(bb.originX), y = Math.floor(bb.originY), bw = Math.floor(bb.width), bh = Math.floor(bb.height);
        if (bw <= 0 || bh <= 0) continue;
        ctx.strokeRect(x, y, bw, bh);
      }
      ctx.restore();
    }

    function median(arr) {
      if (arr.length === 0) return 0; const s = [...arr].sort((a,b)=>a-b); const mid = Math.floor(s.length/2);
      return s.length % 2 ? s[mid] : (s[mid-1] + s[mid]) / 2;
    }
    function p95(arr) {
      if (arr.length === 0) return 0; const s = [...arr].sort((a,b)=>a-b); const idx = Math.floor(0.95*(s.length-1)); return s[idx];
    }

    // Initialize ONNX WASM detector
    async function initWasmDetector() {
      // You can download a small SSD-MobileNet ONNX to frontend/models:
      // - Example (ONNX Model Zoo): https://github.com/onnx/models (vision/object_detection_segmentation/ssd)
      // Then place at /models/mobilenet_ssd.onnx and use that path below
      try {
        await initDetector('/models/mobilenet_ssd.onnx');
      } catch (e) {
        hudEl.textContent = 'Status: model load failed (WASM). Falling back to face detector not implemented in this viewer.';
      }
    }

    const metrics = {
      startTs: 0,
      frames: 0,
      detectionsFrames: 0,
      latencies: [],
      lastBytes: { up: 0, down: 0, ts: 0 },
      kbps: { up: 0, down: 0 },
      timer: null,
      running: false
    };

    function updateHUD(faceCount) {
      const fps = metrics.frames / Math.max(1, ((Date.now() - metrics.startTs) / 1000));
      const lat50 = Math.round(median(metrics.latencies));
      const lat95 = Math.round(p95(metrics.latencies));
      hudEl.textContent = `Faces: ${faceCount} | FPS: ${fps.toFixed(1)} | Lat (p50/p95): ${lat50}/${lat95} ms | Up/Down: ${Math.round(metrics.kbps.up)}/${Math.round(metrics.kbps.down)} kbps`;
    }

    function saveMetrics(durationSec) {
      const data = {
        mode: 'wasm',
        duration_s: durationSec,
        median_latency_ms: Math.round(median(metrics.latencies)),
        p95_latency_ms: Math.round(p95(metrics.latencies)),
        fps: Number(((metrics.frames) / (durationSec)).toFixed(2)),
        uplink_kbps: Math.round(metrics.kbps.up),
        downlink_kbps: Math.round(metrics.kbps.down)
      };
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const a = document.createElement('a'); a.href = URL.createObjectURL(blob); a.download = 'metrics.json'; a.click();
    }

    function computeBitrates(pc) {
      const now = Date.now();
      pc.getStats(null).then((report) => {
        let upBytes = 0, downBytes = 0;
        report.forEach((s) => {
          if (s.type === 'outbound-rtp' && s.kind === 'video') upBytes += s.bytesSent || 0;
          if (s.type === 'inbound-rtp' && s.kind === 'video') downBytes += s.bytesReceived || 0;
        });
        if (metrics.lastBytes.ts) {
          const dt = (now - metrics.lastBytes.ts) / 1000;
          metrics.kbps.up = ((upBytes - metrics.lastBytes.up) * 8) / 1000 / Math.max(0.001, dt);
          metrics.kbps.down = ((downBytes - metrics.lastBytes.down) * 8) / 1000 / Math.max(0.001, dt);
        }
        metrics.lastBytes = { up: upBytes, down: downBytes, ts: now };
      }).catch(() => {});
    }

    async function start() {
      await initWasmDetector();

      // Prepare room & QR
      const room = roomId();
      const phoneUrl = getLANUrl(`/phone.html?room=${room}`);
      drawMiniQR(qrCanvas, phoneUrl);
      joinUrlEl.textContent = phoneUrl;

      const { ws, opened } = connectSignaling(room, 'viewer');
      await opened;

      const pc = createPeerConnection((candidate) => ws.send(JSON.stringify({ type: 'ice', room, candidate })), (stream) => {
        remoteVideo.srcObject = stream;
      }, () => {});

      ws.onmessage = async (ev) => {
        let msg; try { msg = JSON.parse(ev.data); } catch { return; }
        if (msg.type === 'peer_joined' && msg.room === room) {
          const offer = await makeOffer(pc);
          ws.send(JSON.stringify({ type: 'offer', room, sdp: offer.sdp }));
        } else if (msg.type === 'answer' && msg.room === room) {
          await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
        } else if (msg.type === 'ice' && msg.room === room) {
          try { await pc.addIceCandidate(msg.candidate); } catch (_) {}
        }
      };

      // Telemetry channel (from phone)
      let lastTelemetry = null;
      pc.ondatachannel = (ev) => {
        if (ev.channel.label === 'telemetry') {
          ev.channel.onmessage = (e) => {
            try { lastTelemetry = JSON.parse(e.data); } catch (_) {}
          };
        }
      };

      // Frame capture + WASM inference with thinning to ~12 FPS
      let lastFrameId = 0;
      const CAPTURE_INTERVAL_MS = Math.round(1000 / CONFIG.TARGET_FPS);
      setInterval(async () => {
        if (remoteVideo.readyState < 2) return;
        try {
          resizeCanvasToVideo();
          const bitmap = await createImageBitmap(remoteVideo);
          const meta = { frame_id: (lastTelemetry && lastTelemetry.frame_id) || (++lastFrameId), capture_ts: (lastTelemetry && lastTelemetry.capture_ts) || Date.now() };
          enqueueFrame(bitmap, meta);
        } catch (_) {}
      }, CAPTURE_INTERVAL_MS);

      // Process results and draw overlay
      startProcessing((result) => {
        // result: { frame_id, capture_ts, recv_ts, inference_ts, detections }
        // Convert normalized boxes to pixel rects and draw
        const w = overlay.width, h = overlay.height;
        const dets = (result.detections || []).map(d => ({
          boundingBox: {
            originX: Math.max(0, Math.floor((d.xmin || 0) * w)),
            originY: Math.max(0, Math.floor((d.ymin || 0) * h)),
            width: Math.floor(Math.max(0, (d.xmax - d.xmin)) * w),
            height: Math.floor(Math.max(0, (d.ymax - d.ymin)) * h)
          },
          label: d.label,
          score: d.score
        }));
        drawDetections(dets);

        const overlayTs = Date.now();
        if (metrics.running) {
          metrics.frames++;
          if (dets.length > 0) metrics.detectionsFrames++;
          if (lastTelemetry && lastTelemetry.capture_ts) metrics.latencies.push(overlayTs - lastTelemetry.capture_ts);
        }
        updateHUD(dets.length);
        // Log per-frame JSON (optional)
        // console.log(result);
      });

      // Metrics controls
      startBtn.onclick = () => {
        metrics.running = true; metrics.startTs = Date.now(); metrics.frames = 0; metrics.detectionsFrames = 0; metrics.latencies = [];
        startBtn.disabled = true; saveBtn.disabled = true;
        const duration = 30; // seconds
        metrics.timer = setInterval(() => computeBitrates(pc), 1000);
        setTimeout(() => {
          metrics.running = false; clearInterval(metrics.timer); startBtn.disabled = false; saveBtn.disabled = false;
          updateHUD(0);
          saveBtn.onclick = () => saveMetrics(duration);
        }, duration * 1000);
      };

      window.addEventListener('resize', resizeCanvasToVideo);
      remoteVideo.addEventListener('loadedmetadata', resizeCanvasToVideo);
    }

    start();
  </script>
</body>
</html>


